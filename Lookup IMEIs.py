# -*- coding: utf-8 -*-
"""FILTRADO DE DATOS COMPLETO 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jKTYn1qCS6cwQrfQ82VKUJW-HWZFCcqx

# FILTRADO DE DATOS COMPLETO 2:
"""

import pandas as pd

# ==============================================================================
# Función para cargar los archivos Excel
# ==============================================================================
def load_excel_files(pedido_path, stock_path):
    """Carga los archivos Excel de pedido y stock en DataFrames de pandas."""
    try:
        df_pedido = pd.read_excel(pedido_path, engine='openpyxl')
        print(f"Archivo Pedido '{pedido_path}' cargado exitosamente.")
    except FileNotFoundError:
        print(f"Error: El archivo Pedido '{pedido_path}' no fue encontrado.")
        return None, None
    except Exception as e:
        print(f"Error al leer el archivo Pedido '{pedido_path}': {e}")
        return None, None

    try:
        df_stock = pd.read_excel(stock_path, engine='openpyxl')
        print(f"Archivo Stock '{stock_path}' cargado exitosamente.")
    except FileNotFoundError:
        print(f"Error: El archivo Stock '{stock_path}' no fue encontrado.")
        return df_pedido, None # Devuelve pedido si se cargó, pero no stock
    except Exception as e:
        print(f"Error al leer el archivo Stock '{stock_path}': {e}")
        return df_pedido, None # Devuelve pedido si se cargó, pero no stock

    return df_pedido, df_stock

# ==============================================================================
# Función para normalizar columnas (minúsculas, sin espacios)
# ==============================================================================
def normalize_columns(df, column_name):
    """Convierte una columna a minúsculas y elimina espacios."""
    if column_name in df.columns:
        # Asegurarse de que la columna es de tipo string antes de aplicar métodos str
        df[column_name] = df[column_name].astype(str).str.lower().str.replace(' ', '', regex=False)
    else:
        print(f"Advertencia: La columna '{column_name}' no existe en el DataFrame y no será normalizada.")
    return df

# ==============================================================================
# Función para mapear los grados de 'Pedido' a los de 'Stock'
# ==============================================================================
def map_grades(df, grade_column):
    """Mapea los valores de grado ('a', 'b', 'c') a ('mint', 'good', 'fair')."""
    if grade_column in df.columns:
        grade_mapping = {'a': 'mint', 'b': 'good', 'c': 'fair'}
        # Asegurarse de que la columna es de tipo string antes de aplicar métodos str
        original_type = df[grade_column].dtype
        df[grade_column+'_original'] = df[grade_column] # Guardar original por si acaso

        df[grade_column] = df[grade_column].astype(str).str.lower().map(grade_mapping)

        # Reportar valores no mapeados
        unmapped_count = df[grade_column].isna().sum()
        if unmapped_count > 0:
             print(f"Advertencia: {unmapped_count} valores en la columna '{grade_column+'_original'}' no pudieron ser mapeados a 'mint', 'good' o 'fair'.")
             # Podrías imprimir los valores no mapeados si es necesario:
             # print(df[df[grade_column].isna()][grade_column+'_original'].unique())
    else:
         print(f"Advertencia: La columna '{grade_column}' no existe en el DataFrame y no será mapeada.")
    return df

# ==============================================================================
# Función principal para filtrar el stock según el pedido con notificaciones
# ==============================================================================
def filter_by_qty_and_battery(df_pedido, df_stock_original):
    """
    Filtra el DataFrame de stock basado en los requisitos del DataFrame de pedido,
    manejando cantidad y condición de batería, notifica sobre pedidos no satisfechos,
    y calcula el total de unidades faltantes.
    """
    if df_pedido is None or df_stock_original is None:
        print("Error: No se pueden procesar los datos porque uno o ambos DataFrames no se cargaron correctamente.")
        return pd.DataFrame(), 0 # Devuelve DataFrame vacío y 0 faltantes

    df_stock = df_stock_original.copy()
    selected_rows_list = []
    used_imeis = set()
    total_shortfall = 0 # <--- Inicializar contador de faltantes

    print("\n--- Verificando Pedido contra Stock Disponible ---")

    # Iterar sobre cada fila del pedido
    for index, pedido_row in df_pedido.iterrows():
        # Extraer datos de la fila del pedido, manejando posibles faltantes
        model = pedido_row.get('Model', 'N/A')
        color = pedido_row.get('Colour', 'N/A')
        grade = pedido_row.get('Grade', None) # Grado ya mapeado ('mint', 'good', 'fair') o NaN/None
        qty_needed = pedido_row.get('Qty', 0)
        battery_condition_str = pedido_row.get('Batería>80%', 'N/A')

        row_label = f"Pedido Fila {index + 2}" # Para mensajes

        # --- Validaciones de la fila del pedido ---
        valid_row = True
        if pd.isna(grade):
            original_grade = pedido_row.get('Grade_original', 'N/A')
            print(f"(!) {row_label}: IGNORADA - Grado '{original_grade}' no válido o no mapeado.")
            valid_row = False

        try:
            qty_needed = int(qty_needed)
            if qty_needed <= 0:
                 print(f"(!) {row_label}: IGNORADA - Cantidad '{qty_needed}' no válida.")
                 valid_row = False
        except (ValueError, TypeError):
            print(f"(!) {row_label}: IGNORADA - Cantidad '{qty_needed}' no es un número entero válido.")
            valid_row = False

        if not valid_row:
            continue # Saltar esta fila del pedido

        # --- Definir filtro de batería ---
        if isinstance(battery_condition_str, str) and battery_condition_str.lower() == 'yes':
            battery_filter = (df_stock['Battery Percent'] >= 80) | (df_stock['Battery Percent'].isna())
            battery_req_str = ">= 80% o N/A"
        else: # Asume 'no', NaN, o cualquier otro valor como < 80%
            battery_filter = (df_stock['Battery Percent'] < 80) | (df_stock['Battery Percent'].isna())
            battery_req_str = "< 80% o N/A"

        # --- Filtrar stock disponible ---
        potential_matches = df_stock[
            (df_stock['Model'].astype(str) == str(model)) &
            (df_stock['Colour'].astype(str) == str(color)) &
            (df_stock['BM Grade'].astype(str) == str(grade)) & # Compara con BM Grade del stock
            battery_filter &
            (~df_stock['IMEI'].isin(used_imeis)) # Excluir IMEIs ya usados
        ]

        # --- Determinar cantidad a tomar y calcular faltante para esta fila ---
        num_found = len(potential_matches)
        qty_to_take = min(qty_needed, num_found)
        row_shortfall = qty_needed - qty_to_take # <--- Calcular faltante para esta fila
        total_shortfall += row_shortfall # <--- Acumular el faltante total

        # --- Lógica de Notificación ---
        if num_found == 0:
            # No se encontró NINGÚN dispositivo que coincida con los criterios
            print(f"(X) {row_label}: No se encontraron dispositivos para: "
                  f"Modelo='{model}', Color='{color}', Grado='{grade}', Batería='{battery_req_str}'. "
                  f"(Faltaron {row_shortfall})") # Añadido faltante aquí también
        else:
            # Se encontraron algunos dispositivos, verificar si la cantidad es suficiente
            if qty_to_take < qty_needed:
                # Se encontraron algunos, pero no suficientes
                print(f"(!) {row_label}: Cantidad insuficiente para: "
                      f"Modelo='{model}', Color='{color}', Grado='{grade}', Batería='{battery_req_str}'. "
                      f"Se necesitaban {qty_needed}, se encontraron {num_found} disponibles. "
                      f"Se asignarán {qty_to_take}. (Faltaron {row_shortfall})") # Añadido faltante
            # else: # Opcional: Notificar si se cumple exactamente
            #    print(f"(✓) {row_label}: Cantidad suficiente ({num_found} disp.) para {qty_needed} de: "
            #          f"Modelo='{model}', Color='{color}', Grado='{grade}', Batería='{battery_req_str}'. Se asignarán {qty_to_take}. (Faltaron {row_shortfall})") # Añadido faltante (será 0)

            # --- Selección de filas ---
            if qty_to_take > 0:
                selected_stock_rows = potential_matches.head(qty_to_take)
                selected_rows_list.append(selected_stock_rows)
                used_imeis.update(selected_stock_rows['IMEI'])

    print("--- Fin Verificación ---")

    # --- Imprimir Resumen de Faltantes ---
    print(f"\nResumen: Faltaron un total de {total_shortfall} dispositivos para completar todas las líneas del pedido.") # <--- Mensaje Resumen

    # Concatenar todas las filas seleccionadas al final
    if selected_rows_list:
        filtered_df = pd.concat(selected_rows_list, ignore_index=True)
    else:
        print("\nAdvertencia: No se asignó ningún dispositivo del stock al pedido.")
        if df_stock_original is not None:
             filtered_df = pd.DataFrame(columns=df_stock_original.columns)
        else:
             filtered_df = pd.DataFrame()

    # Devolver también el total faltante
    return filtered_df, total_shortfall # <--- Devolver el total faltante

# ==============================================================================
# Función para seleccionar columnas específicas
# ==============================================================================
def select_columns(df, columns):
    """Selecciona un subconjunto de columnas de un DataFrame."""
    if df is None or df.empty:
         return pd.DataFrame(columns=columns) # Devuelve vacío con columnas esperadas

    # Asegurarse de que todas las columnas existan antes de seleccionar
    existing_columns = [col for col in columns if col in df.columns]
    missing_columns = [col for col in columns if col not in df.columns]
    if missing_columns:
        print(f"Advertencia: Las siguientes columnas solicitadas no se encontraron en el DataFrame resultante y no se incluirán: {missing_columns}")

    return df[existing_columns]

# ==============================================================================
# Función para guardar el DataFrame en Excel
# ==============================================================================
def save_to_excel(df, file_name):
    """Guarda un DataFrame en un archivo Excel."""
    if df is None:
        print("Error: No hay datos para guardar.")
        return
    try:
        df.to_excel(file_name, index=False, engine='openpyxl')
        print(f"\nEl resultado ({len(df)} filas) se ha guardado exitosamente en '{file_name}'.")
    except Exception as e:
        print(f"\nError al guardar el archivo '{file_name}': {e}")

# ==============================================================================
# --- Flujo Principal de Ejecución ---
# ==============================================================================
if __name__ == "__main__":

    # --- Configuración ---
    pedido_file = 'Pedido.xlsx'
    stock_file = 'Stock.xlsx'
    output_file = 'resultado_asignacion.xlsx' # Nombre de archivo de salida más descriptivo

    # Columnas requeridas en cada archivo (ajusta según tus nombres exactos)
    pedido_cols_needed = ['Model', 'Colour', 'Grade', 'Qty', 'Batería>80%']
    stock_cols_needed = ['Model', 'Colour', 'BM Grade', 'IMEI', 'Battery Percent']
    output_cols = ['Model', 'Colour', 'Grade', 'IMEI', 'Battery Percent'] # Columnas finales deseadas

    # --- Carga de Datos ---
    print("Iniciando proceso de asignación...")
    df_pedido_raw, df_stock_raw = load_excel_files(pedido_file, stock_file)

    # Salir si los archivos no se pudieron cargar
    if df_pedido_raw is None or df_stock_raw is None:
        print("Proceso detenido debido a errores en la carga de archivos.")
    else:
        # --- Preparación de df_pedido ---
        print("\nProcesando archivo de Pedido...")
        # Verificar y seleccionar columnas requeridas de Pedido
        missing_pedido_cols = [col for col in pedido_cols_needed if col not in df_pedido_raw.columns]
        if missing_pedido_cols:
            print(f"Error: Faltan las siguientes columnas requeridas en '{pedido_file}': {missing_pedido_cols}")
            df_pedido = None # Marcar como inválido
        else:
            df_pedido = df_pedido_raw[pedido_cols_needed].copy() # Usar .copy() para evitar SettingWithCopyWarning
            # Normalizar columnas clave de Pedido
            df_pedido = normalize_columns(df_pedido, 'Colour')
            df_pedido = normalize_columns(df_pedido, 'Model')
            # Mapear y normalizar Grade en Pedido (crea Grade_original y modifica Grade)
            df_pedido = map_grades(df_pedido, 'Grade')

        # --- Preparación de df_stock ---
        print("\nProcesando archivo de Stock...")
        # Verificar y seleccionar columnas requeridas de Stock
        missing_stock_cols = [col for col in stock_cols_needed if col not in df_stock_raw.columns]
        if missing_stock_cols:
             print(f"Error: Faltan las siguientes columnas requeridas en '{stock_file}': {missing_stock_cols}")
             df_stock = None # Marcar como inválido
        else:
            df_stock = df_stock_raw[stock_cols_needed].copy() # Usar .copy()
            # Convertir la columna 'Battery Percent' a valores numéricos
            df_stock['Battery Percent_original'] = df_stock['Battery Percent']
            df_stock['Battery Percent'] = pd.to_numeric(df_stock['Battery Percent'], errors='coerce')
            num_bat_errors = df_stock['Battery Percent'].isna().sum() - df_stock['Battery Percent_original'].isna().sum()
            if num_bat_errors > 0:
                 print(f"Advertencia: {num_bat_errors} valores en 'Battery Percent' no pudieron ser convertidos a número y se tratarán como N/A.")

            # Normalizar columnas clave de Stock
            df_stock = normalize_columns(df_stock, 'Colour')
            df_stock = normalize_columns(df_stock, 'Model')
            df_stock = normalize_columns(df_stock, 'BM Grade')

        # --- Filtrado y Asignación ---
        # Solo proceder si ambos dataframes fueron preparados correctamente
        if df_pedido is not None and df_stock is not None:
            # Llamar a la función principal de filtrado y asignación
            # Ahora devuelve también el total faltante
            assigned_stock_df, total_faltante = filter_by_qty_and_battery(df_pedido, df_stock)

            # --- Preparación del Resultado Final ---
            print("\nPreparando archivo de resultado...")
            # Seleccionar las columnas deseadas para el archivo de salida
            result_df = select_columns(assigned_stock_df, stock_cols_needed)

            # Renombrar 'BM Grade' a 'Grade' si existe
            if 'BM Grade' in result_df.columns:
                 result_df = result_df.rename(columns={'BM Grade': 'Grade'})

            # Reordenar y seleccionar las columnas finales exactas deseadas
            result_df = select_columns(result_df, output_cols)

            # --- Guardar Resultado ---
            save_to_excel(result_df, output_file)
        else:
            print("\nProceso detenido: No se pudo completar la preparación de los dataframes de Pedido y/o Stock debido a errores previos.")

    print("\nProceso de asignación finalizado.")